# .github/workflows/cd.yml
name: CD - Deploy to Environment

on:
  workflow_run:
    workflows: ["CI - Build and Push Images"]
    branches: [main]
    types: [completed]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - production
      image_tag:
        description: 'Image tag to deploy (default: latest commit sha)'
        required: false
        type: string

env:
  REGISTRY: docker.io
  IMAGE_TAG: ${{ github.event.workflow_run.head_sha || github.event.inputs.image_tag || github.sha }}

jobs:
  deploy:
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    runs-on: self-hosted
    outputs:
      environment: ${{ steps.vars.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}
    environment: 
      name: ${{ github.event.inputs.environment || 'development' }}
      url: ${{ steps.deploy.outputs.url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: vars
        run: |
          ENV="${{ github.event.inputs.environment || 'development' }}"
          TAG="${{ env.IMAGE_TAG }}"
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "image_tag=${TAG}" >> $GITHUB_OUTPUT
          echo "compose_file=infra/docker-compose.${ENV}.yml" >> $GITHUB_OUTPUT

      - name: Validate Docker Compose file
        run: |
          cd infra
          echo "üîç Validating Docker Compose configuration..."
          
          # Check if compose file exists
          if [ ! -f docker-compose.yml ]; then
            echo "‚ùå docker-compose.yml not found!"
            exit 1
          fi
          
          # Validate compose file syntax
          if ! docker-compose -f docker-compose.yml config > /dev/null 2>&1; then
            echo "‚ùå Docker Compose file validation failed!"
            echo "Detailed error:"
            docker-compose -f docker-compose.yml config
            exit 1
          fi
          
          echo "‚úÖ Docker Compose file is valid"

      - name: Create environment files
        run: |
          cd infra
          
          # Create main .env file
          cat > .env << EOF
          ENVIRONMENT=${{ steps.vars.outputs.environment }}
          IMAGE_TAG=${{ steps.vars.outputs.image_tag }}
          
          # Database Configuration
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=root
          POSTGRES_DB=utility_services
          DATABASE_URL=postgresql://postgres:root@postgres:5432/utility_services
          
          # Kafka Configuration
          KAFKA_BOOTSTRAP_SERVERS=kafka:9092
          ZOOKEEPER_CONNECT=zookeeper:2181
          
          # Redis Configuration
          REDIS_URL=redis://redis:6379
          
          # SMTP Configuration (as strings)
          SMTP_HOST=smtp.gmail.com
          SMTP_PORT=587
          SMTP_USER=your-email@gmail.com
          SMTP_PASS=your-app-password
          SMTP_IS_SECURE=true
          
          # JWT Configuration
          JWT_SECRET=your-super-secret-jwt-key-change-in-production
          JWT_EXPIRES_IN=24h
          
          # API Configuration
          API_PORT=3000
          NODE_ENV=${{ steps.vars.outputs.environment }}
          EOF
          
          echo "‚úÖ Environment file created"

      - name: Stop existing containers
        run: |
          cd infra
          echo "üõë Stopping existing containers..."
          docker-compose -f docker-compose.yml down --remove-orphans || true
          
          # Clean up any orphaned containers
          docker container prune -f || true
        continue-on-error: true

      - name: Pull latest images
        run: |
          cd infra
          echo "üì• Pulling latest images..."
          
          # Pull infrastructure images
          docker pull postgres:13
          docker pull confluentinc/cp-zookeeper:latest
          docker pull confluentinc/cp-kafka:latest
          docker pull redis:6-alpine
          
          # Try to pull application images (some might be built locally)
          docker-compose -f docker-compose.yml pull || echo "Some images might be built locally, continuing..."

      - name: Deploy infrastructure services
        id: deploy-infra
        run: |
          cd infra
          
          echo "üöÄ Starting infrastructure services..."
          
          # Start Zookeeper first
          echo "Starting Zookeeper..."
          docker-compose -f docker-compose.yml up -d zookeeper
          
          # Wait for Zookeeper with better health check
          echo "‚è≥ Waiting for Zookeeper..."
          ZOOKEEPER_READY=false
          ZK_WAIT_COUNT=0
          MAX_ZK_WAIT=12
          
          while [ "$ZOOKEEPER_READY" = false ] && [ $ZK_WAIT_COUNT -lt $MAX_ZK_WAIT ]; do
            echo "Checking Zookeeper... attempt $((ZK_WAIT_COUNT + 1))/$MAX_ZK_WAIT"
            if docker exec zookeeper zkServer.sh status >/dev/null 2>&1 || \
               docker exec zookeeper nc -z localhost 2181 >/dev/null 2>&1; then
              ZOOKEEPER_READY=true
              echo "‚úÖ Zookeeper is ready!"
            else
              sleep 5
              ((ZK_WAIT_COUNT++))
            fi
          done
          
          if [ "$ZOOKEEPER_READY" = false ]; then
            echo "‚ùå Zookeeper failed to start"
            docker logs zookeeper --tail 20
            exit 1
          fi
          
          # Start Postgres
          echo "Starting Postgres..."
          docker-compose -f docker-compose.yml up -d postgres
          
          # Wait for Postgres
          echo "‚è≥ Waiting for Postgres..."
          POSTGRES_READY=false
          POSTGRES_WAIT_COUNT=0
          MAX_POSTGRES_WAIT=12
          
          while [ "$POSTGRES_READY" = false ] && [ $POSTGRES_WAIT_COUNT -lt $MAX_POSTGRES_WAIT ]; do
            echo "Checking Postgres... attempt $((POSTGRES_WAIT_COUNT + 1))/$MAX_POSTGRES_WAIT"
            if docker exec postgres pg_isready -U postgres >/dev/null 2>&1; then
              POSTGRES_READY=true
              echo "‚úÖ Postgres is ready!"
            else
              sleep 5
              ((POSTGRES_WAIT_COUNT++))
            fi
          done
          
          if [ "$POSTGRES_READY" = false ]; then
            echo "‚ùå Postgres failed to start"
            docker logs postgres --tail 20
            exit 1
          fi
          
          # Start Redis
          echo "Starting Redis..."
          docker-compose -f docker-compose.yml up -d redis
          sleep 5
          
          # Start Kafka after Zookeeper is ready
          echo "Starting Kafka..."
          docker-compose -f docker-compose.yml up -d kafka
          
          # Wait for Kafka with improved health check
          echo "‚è≥ Waiting for Kafka..."
          KAFKA_READY=false
          KAFKA_WAIT_COUNT=0
          MAX_KAFKA_WAIT=30  # Kafka can take longer
          
          while [ "$KAFKA_READY" = false ] && [ $KAFKA_WAIT_COUNT -lt $MAX_KAFKA_WAIT ]; do
            echo "Checking Kafka... attempt $((KAFKA_WAIT_COUNT + 1))/$MAX_KAFKA_WAIT"
            
            # Check if kafka container is running
            if ! docker ps | grep -q kafka; then
              echo "‚ùå Kafka container is not running!"
              docker logs kafka --tail 20
              exit 1
            fi
            
            # Multiple kafka health check methods
            if docker exec kafka kafka-topics --bootstrap-server localhost:9092 --list >/dev/null 2>&1 || \
               docker exec kafka kafka-broker-api-versions --bootstrap-server localhost:9092 >/dev/null 2>&1; then
              KAFKA_READY=true
              echo "‚úÖ Kafka is ready!"
            else
              sleep 5
              ((KAFKA_WAIT_COUNT++))
            fi
          done
          
          if [ "$KAFKA_READY" = false ]; then
            echo "‚ùå Kafka failed to start within timeout"
            echo "Kafka logs:"
            docker logs kafka --tail 50
            exit 1
          fi
          
          echo "‚úÖ All infrastructure services are ready"

      - name: Deploy application services
        id: deploy
        run: |
          cd infra
          
          echo "üöÄ Starting application services..."
          
          # Start all services
          docker-compose -f docker-compose.yml up -d
          
          # Wait for services to initialize
          echo "‚è≥ Waiting for services to initialize..."
          sleep 60
          
          # Health check for application services
          HEALTHY_COUNT=0
          TOTAL_SERVICES=13
          
          services=(
            "analytics-reporting-service"
            "billing-service"
            "collection-management-service"
            "consumer-service"
            "customer-support-service"
            "gis-location-management-service"
            "meter-management-inventory-service"
            "notification-communication-service"
            "policy-management-service"
            "third-party-integration-gateway-service"
            "user-identity-access-management-service"
            "user-service"
            "workflow-approval-service"
          )
          
          for service in "${services[@]}"; do
            if docker ps --filter "name=${service}" --filter "status=running" | grep -q "${service}"; then
              echo "‚úÖ ${service} is running"
              ((HEALTHY_COUNT++))
            else
              echo "‚ùå ${service} is not running"
              # Show last 20 lines of logs for debugging
              echo "Last 20 lines of ${service} logs:"
              docker logs ${service} --tail 20 2>/dev/null || echo "Could not retrieve logs for ${service}"
              echo "---"
            fi
          done
          
          echo "üìä Services Status: ${HEALTHY_COUNT}/${TOTAL_SERVICES} healthy"
          
          # Require at least 80% of services to be healthy
          REQUIRED_HEALTHY=$((TOTAL_SERVICES * 80 / 100))
          if [ ${HEALTHY_COUNT} -lt ${REQUIRED_HEALTHY} ]; then
            echo "‚ùå Only ${HEALTHY_COUNT}/${TOTAL_SERVICES} services are healthy (need at least ${REQUIRED_HEALTHY})"
            echo "Deployment failed - not enough services are running"
            exit 1
          fi
          
          # Set deployment URL
          if [ "${{ steps.vars.outputs.environment }}" == "production" ]; then
            echo "url=https://api.utility-services.com" >> $GITHUB_OUTPUT
          else
            echo "url=https://dev-api.utility-services.com" >> $GITHUB_OUTPUT
          fi
          
          echo "‚úÖ Application deployment completed successfully"

      - name: Run smoke tests
        run: |
          echo "üß™ Running smoke tests..."
          sleep 30
          
          FAILED_TESTS=0
          
          # Test service connectivity
          services_ports=(
            "analytics-reporting-service:3000"
            "billing-service:3001"
            "collection-management-service:3002"
            "consumer-service:3003"
            "customer-support-service:3004"
            "gis-location-management-service:3005"
            "meter-management-inventory-service:3006"
            "notification-communication-service:3007"
            "policy-management-service:3008"
            "third-party-integration-gateway-service:3009"
            "user-identity-access-management-service:3010"
            "user-service:3011"
            "workflow-approval-service:3012"
          )
          
          for service_port in "${services_ports[@]}"; do
            service_name=$(echo $service_port | cut -d: -f1)
            port=$(echo $service_port | cut -d: -f2)
            
            echo "Testing ${service_name} on port ${port}..."
            
            # Try multiple endpoints
            if curl -f -s --max-time 10 "http://localhost:${port}/health" >/dev/null 2>&1; then
              echo "‚úÖ ${service_name} health endpoint OK"
            elif curl -f -s --max-time 10 "http://localhost:${port}/" >/dev/null 2>&1; then
              echo "‚úÖ ${service_name} root endpoint OK"
            elif nc -z localhost ${port} 2>/dev/null; then
              echo "‚úÖ ${service_name} port ${port} is accessible"
            else
              echo "‚ùå ${service_name} failed all connectivity tests"
              ((FAILED_TESTS++))
            fi
          done
          
          PASSED_TESTS=$((13 - FAILED_TESTS))
          echo "üìä Smoke Tests: ${PASSED_TESTS}/13 passed"
          
          # Allow some failures but not too many
          if [ ${FAILED_TESTS} -gt 4 ]; then
            echo "‚ùå Too many services failed smoke tests (${FAILED_TESTS} failures)"
            exit 1
          fi
          
          echo "‚úÖ Smoke tests completed with acceptable results"

      - name: Cleanup old resources
        run: |
          echo "üßπ Cleaning up old resources..."
          cd infra
          
          # Remove unused images
          docker image prune -f
          
          # Remove unused volumes (be careful with this)
          docker volume prune -f || true
          
          echo "‚úÖ Cleanup completed"

      - name: Display deployment summary
        if: success()
        run: |
          echo "üéâ Deployment Summary"
          echo "===================="
          echo "Environment: ${{ steps.vars.outputs.environment }}"
          echo "Image Tag: ${{ steps.vars.outputs.image_tag }}"
          echo "Deployment URL: ${{ steps.deploy.outputs.url }}"
          echo "Timestamp: $(date)"
          echo ""
          echo "üìä Final Service Status:"
          cd infra
          docker-compose ps
          echo ""
          echo "üìà Resource Usage:"
          docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üîÑ Rolling back deployment..."
          cd infra
          
          echo "Stopping all services..."
          docker-compose -f docker-compose.yml down --remove-orphans
          
          echo "Cleaning up failed containers..."
          docker container prune -f
          
          echo "‚ùå Deployment failed and has been rolled back"

  notify:
    needs: deploy
    runs-on: self-hosted
    if: always()
    steps:
      - name: Notify deployment status
        run: |
          echo "üì¢ Deployment Notification"
          echo "========================="
          
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ DEPLOYMENT SUCCESS"
            echo "Environment: ${{ needs.deploy.outputs.environment || 'development' }}"
            echo "URL: ${{ needs.deploy.outputs.url }}"
            echo "Timestamp: $(date)"
          else
            echo "‚ùå DEPLOYMENT FAILED"
            echo "Environment: ${{ needs.deploy.outputs.environment || 'development' }}"
            echo "Check the logs for detailed error information"
            echo "Timestamp: $(date)"
          fi